name: Latest Working Pipeline

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  #push:
   # branches: [ "main" ]
  #pull_request:
   # branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
  
permissions:
  id-token: write #Write permission required to authenticate with OIDC
  
# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  ConnectToEC2:
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@main 
        with:
          role-to-assume: ${{ secrets.EC2_ACCESS_ROLE_ARN }}
          aws-region: eu-west-1
      - name: Start EC2
        uses: flyweightrocks/aws-ec2-action@v1
        with:
          instance-id: ${{ secrets.EC2_INSTANCE_ID }}
          wait-instance-running: true
          stop-instance: false
      - name: Run Commands
        run: | #Maybe Place Commands in Bash Script instead to make this neater
          command_id=$(aws ssm send-command \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[
            \"bash /home/ubuntu/run_eca_categories.sh ${{ vars.CATEGORY }} ${{ vars.CORE_COUNT }} ${{ vars.TIME_BUDGET }} ${{ vars.DEBUG_MODE }} ${{ vars.TESTCOV_SETTING }} ${{ vars.STACK_SIZE }}\"
            ]" \
          --targets "Key=instanceids,Values=${{ secrets.EC2_INSTANCE_ID }}" \
          --output-s3-bucket-name "${{ secrets.S3_BUCKET_NAME }}" \
          --output-s3-key-prefix "ssm-outputs" \
          --query "Command.CommandId" \
          --output text)

          # Poll for the command status until it completes
          while true; do
            # Get the current status of the command
            status=$(aws ssm list-command-invocations \
              --command-id "$command_id" \
              --query "CommandInvocations[0].Status" \
              --output text)
          
          echo "Current command status: $status"

           if [[ "$status" == "Failed" ]]; then
            error_message=$(aws ssm list-command-invocations \
              --command-id "$command_id" \
              --query "CommandInvocations[0].CommandPlugins[0].ErrorMessage" \
              --output text)
            echo "Error message: $error_message"
            break
          fi
          echo "Command sent with Command ID: $command_id"
          
            # Exit the loop if the command has completed (Success, Failed, TimedOut)
            if [[ "$status" == "Success" || "$status" == "Failed" || "$status" == "TimedOut" ]]; then
              echo "Command completed with status: $status"
              break
            fi
          
            # Wait for 120 seconds before checking again
            sleep 120
          done

      - name: Invoke Lambda Function For Processing
        run: |
          aws lambda invoke --function-name ${{ secrets.LAMBDA_NAME }} \
          --cli-binary-format raw-in-base64-out \
          --payload '{ }' response.json
          URL=$(jq -r '.body | fromjson | .url' response.json) #Using the jq JSON command line processor to isolate the value of the url key
          echo "$URL" | awk -F '?' '{print $1}' #Using the text processor awk to try and remove the unnecessary parts of the html url
          
      - name: Stop EC2 #Keeping this commented for further testing to check the results of the pipeline commands
        uses: flyweightrocks/aws-ec2-action@v1
        with:
          instance-id: ${{ secrets.EC2_INSTANCE_ID }}
          wait-instance-running: false
          stop-instance: true
